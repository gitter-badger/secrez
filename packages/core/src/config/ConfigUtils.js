const path = require('path')
const Utils = require('../utils')
const fs = require('fs-extra')
const pkg = require('../../package')
const config = require('.')

class ConfigUtils {

  static isValidType(type) {
    type = parseInt(type)
    for (let t in config.types) {
      if (config.types[t] === type) {
        return true
      }
    }
    return false
  }

  static async setSecrez(
      config,
      container,
      localWorkingDir
  ) {
    config.container = container
    config.root = path.basename(container)
    config.dataPath = path.join(container, 'data')
    config.workingDir = '/'
    config.localWorkingDir = localWorkingDir
    config.keysPath = path.join(container, 'keys.json')

    config.tmpPath = path.join(container, 'tmp')
    config.envPath = path.join(container, 'env.json')
    config.historyPath = path.join(container, 'history')

    await fs.emptyDir(config.tmpPath)
    await fs.ensureDir(config.dataPath)
    let fPath = path.join(container, 'README')
    if (!await fs.pathExists(fPath)) {
      await fs.writeFile(fPath, `
This folder has been generated by ${Utils.capitalize(pkg.name)} v${pkg.version}.
It contains your secret database. 
Be very careful, and don't touch anything :o)
`, 'utf-8')
      await fs.writeFile(config.envPath, '{}')
    }
    fPath = path.join(container, '.gitignore')
    if (!await fs.pathExists(fPath)) {
      await fs.writeFile(fPath, `tmp
env.json
history
`, 'utf-8')
    }
    return config
  }

  static getDatasetPath(config, index) {
    return config.dataPath + (index > 0 ? `.${index}` : '')
  }

  static setAndGetDataset(config, index) {
    let dataPath = config.dataPath
    if (typeof index === 'number' && parseInt(index.toString()) === index && index > 0) {
      dataPath += '.' + index
      if (!fs.existsSync(dataPath)) {
        let lastData = ConfigUtils.getLastDataset(config)
        if (lastData === path.basename(config.dataPath) + (index > 1 ? '.' + (index - 1) : '')) {
          fs.mkdirSync(dataPath)
        } else {
          throw new Error('Wrong data index')
        }
      }
    }
    return dataPath
  }

  static getLastDataset(config) {
    return ConfigUtils.listDatasets(config).pop()
  }

  static listDatasets(config) {
    return fs.readdirSync(config.container).sort().filter(e => /^data/.test(e))
  }

  static async getEnv() {
    return JSON.parse(await fs.readFile(config.envPath, 'utf8'))
  }

  static async putEnv(env) {
    return await fs.writeFile(config.envPath, JSON.stringify(env))
  }

}

module.exports = ConfigUtils
