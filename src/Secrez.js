const path = require('path')
const pkg = require('../package')
const fs = require('./utils/fs')
const Crypto = require('./utils/Crypto')
const Manifest = require('./models/Manifest')
const Secret = require('./models/Secret')
const Db = require('./utils/Db')
const ursa = require('ursa')
const {status, errors, keys, DEFSALT} = require('./config/constants')
const {CONSTRUCTED, INITIATED, READY, OPERATIVE} = status
const hostname = require('os').hostname().toLowerCase()

class Secrez {

  constructor(dataParentDir) {

    this.db = new Db
    this.dataParentDir = path.join(dataParentDir || process.env.DATA_PARENT_DIR || process.env.HOME, '.secrez')
    if (!/^\//.test(this.dataParentDir)) {
      this.dataParentDir = path.resolve(__dirname, '..', this.dataParentDir)
    }
    if (!fs.existsSync(this.dataParentDir)) {
      fs.ensureDirSync(this.dataParentDir)
      fs.chmodSync(this.dataParentDir, 0o700)
    }
    this.db.init(path.join(this.dataParentDir, 'database'))
    this.set(CONSTRUCTED)
  }

  init() {

    if (this.status === CONSTRUCTED) {

      return this.db.get(keys.CONFIG)
          .then(config => {
            if (config) {
              this.config = JSON.parse(config)
              if (!this.config[hostname]) {
                this.config[hostname] = {}
              }
            } else {
              this.config = {}
              this.config[hostname] = {}
            }
            if (process.env.PRIVATE_KEY) {
              this.privateKeyAbsolutePath = process.env.PRIVATE_KEY
            } else if (this.config.privateKeyAbsolutePath) {
              this.privateKeyAbsolutePath = this.config.privateKeyAbsolutePath
            } else {
              this.privateKeyAbsolutePath = path.resolve(process.env.HOME, '.ssh/id_rsa')
            }
            if (process.env.PUBLIC_KEY) {
              this.publicKeyAbsolutePath = process.env.PUBLIC_KEY
            } else if (this.config.publicKeyAbsolutePath) {
              this.publicKeyAbsolutePath = this.config.publicKeyAbsolutePath
            } else {
              this.publicKeyAbsolutePath = path.resolve(process.env.HOME, '.ssh/id_rsa.pub')
            }
            if (!fs.existsSync(this.privateKeyAbsolutePath) || !fs.existsSync(this.publicKeyAbsolutePath)) {
              return Promise.reject(errors.KeysNotFound)
            }
            try {
              this.privateKey = ursa.createPrivateKey(fs.readFileSync(this.privateKeyAbsolutePath))
              this.publicKey = ursa.openSshPublicKey(fs.readFileSync(this.publicKeyAbsolutePath, 'utf-8'))
            } catch (err) {
              return Promise.reject(errors.BadKeys)
            }
            return Promise.resolve()
          })
          .then(() => {
            const readmePath = path.join(this.dataParentDir, 'README')
            if (!fs.existsSync(readmePath)) {
              return fs.ensureDirAsync(this.dataParentDir)
                  .then(() => {
                    return fs.writeFileAsync(path.join(this.dataParentDir, 'README'), `
This folder has been generated by Secrez v${pkg.version}.
It contains your secret's database. 
Be careful and don't touch anything!
`, 'utf-8')
                  })
            }
            else return Promise.resolve()
          })
          .then(() => {
            this.manifest = new Manifest(this.db)
            this.set(INITIATED)
            return this.getEncryptedMasterKey()
          })
          // .catch(err => console.error(err.stack))
    } else if (this.status === INITIATED) {
      return this.getEncryptedMasterKey()
    } else {
      return Promise.resolve(false)
    }
  }

  getEncryptedMasterKey() {

    return this.db.get(keys.MASTERKEY)
        .then(key => {
          if (key) {
            this.encryptedMasterKey = key
            this.set(READY)
          }
          return Promise.resolve()
        })
  }

  // gitInit(remoteRepo) {
  //   // TODO
  //   // associate the store to a remote repo
  //   return Promise.resolve()
  //       .then(() => {
  //
  //         if (fs.existsSync(path.join(this.dataParentDir, '.git'))) {
  //           // repo exists
  //           return Promise.reject(errors.RepoExists)
  //         } else {
  //           // associate the remoteRepo
  //
  //           return Promise.resolve()
  //         }
  //       })
  // }

  set(status) {
    this.status = status
  }

  is(status) {
    return this.status === status
  }

  signup() {
    if (this.isInitiated()) {
      let masterKey
      return Promise.resolve(Crypto.getRandomString(64))
          .then(randomString => {
            masterKey = randomString
            return Promise.resolve(this.publicKey.encrypt(masterKey, 'utf8', 'base64'))
          })
          .then(encryptedMasterKey => {
            this.encryptedMasterKey = encryptedMasterKey
            return this.db.put(keys.MASTERKEY, encryptedMasterKey)
          })
          .then(() => this.manifest.init(masterKey))
          .then(() => this.setConfig())
          .then(() => Promise.resolve(this.set(OPERATIVE)))
    } else {
      return Promise.reject(errors.NotInitialized)
    }
  }

  setConfig() {
    const conf = this.config[hostname]
    if (conf.privateKeyAbsolutePath !== this.privateKeyAbsolutePath || conf.publicKeyAbsolutePath !== this.publicKeyAbsolutePath) {
      conf.privateKeyAbsolutePath = this.privateKeyAbsolutePath
      conf.publicKeyAbsolutePath = this.publicKeyAbsolutePath
      return this.db.put(keys.CONFIG, JSON.stringify(this.config))
    }
    return Promise.resolve()
  }

  login() {
    if (this.isReady()) {
      return Promise.resolve(this.privateKey.decrypt(this.encryptedMasterKey, 'base64', 'utf8'))
          .then(key => {
            this.manifest = new Manifest(this.db)
            return this.manifest.init(key)
          })
          .then(() => this.setConfig())
          .then(() => Promise.resolve(this.set(OPERATIVE)))
    } else {
      return Promise.reject(errors.NotReady)
    }
  }

  logout() {
    if (this.isOperative()) {
      delete this.manifest
      this.set(CONSTRUCTED)
      return this.init()
          .then(() => {
            return Promise.resolve()
          })
    } else {
      return Promise.resolve(errors.NotOperative)
    }
  }

  hashPassword(password) {
    return Promise.resolve(Crypto.deriveKey(password, DEFSALT))
  }

  ls(params) {
    return Promise.resolve(this.manifest.ls(params))
  }

  setSecret(options) {
    return this.manifest.setSecret(options)
  }

  getSecret(id) {
    if (Db.isValidId(id)) {
      return this.manifest.getSecret(id)
    } else {
      return Promise.reject(errors.InvalidID)
    }
  }

  onClose() {
    this.manifest.onClose()
    delete this.manifest
    delete this.db
  }

  isReady() {
    return this.is(READY)
  }

  isInitiated() {
    return this.is(INITIATED)
  }

  isOperative() {
    return this.is(OPERATIVE)
  }

  static defaultSecretContentFields() {
    return Secret.contentFields()
  }
}

module.exports = Secrez